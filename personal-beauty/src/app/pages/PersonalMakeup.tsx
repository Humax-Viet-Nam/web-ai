/* eslint-disable react-hooks/exhaustive-deps */
/* eslint-disable @typescript-eslint/no-explicit-any */
// src/pages/PersonalMakeup.tsx - Component ph√¢n t√≠ch v√† √°p d·ª•ng makeup ƒë√£ t·ªëi ∆∞u h√≥a
"use client";

import { useState, useEffect, useRef, useCallback, useMemo } from "react";
import { NormalizedLandmark } from "@mediapipe/tasks-vision";
import AnalysisLayout from "../components/AnalysisLayout";
import { useWebcam } from "../context/WebcamContext";
import { useLoading } from "../context/LoadingContext";
import { VIEWS } from "../constants/views";

type FacialFeatures = {
    eyeDistance: number;
    faceWidth: number;
    faceHeight: number;
    noseWidth: number;
    lipWidth: number;
    browLength: number;
    cheekboneProminence: number;
    faceShape: "round" | "oval" | "square" | "heart" | "long";
    foreheadHeight: number;
    cheekboneHeight: number;
};

type FilterType = "natural" | "glamour" | "soft" | "dramatic" | "nude";

export default function PersonalMakeup() {
    const { 
        stream, 
        error: webcamError, 
        restartStream, 
        detectionResults, 
        setCurrentView, 
        handData,
    } = useWebcam();
    const { setIsLoading } = useLoading();
    const [error, setError] = useState<string | null>(null);
    const [isVideoReady, setIsVideoReady] = useState(false);
    const lastStableTime = useRef<number | null>(null);
    const lastUnstableTime = useRef<number | null>(null);
    const STABILITY_THRESHOLD = 15;
    const HISTORY_SIZE = 5;
    const STABILITY_DURATION = 800; // Th·ªùi gian ·ªïn ƒë·ªãnh c·∫ßn thi·∫øt (ms)
    const MIN_STABLE_DURATION = 400; // Th·ªùi gian ·ªïn ƒë·ªãnh t·ªëi thi·ªÉu (ms)
    const [statusMessage, setStatusMessage] = useState<string>("Initializing camera...");
    const [prevStatusMessage, setPrevStatusMessage] = useState<string>("");
    const [isFrameStable, setIsFrameStable] = useState(false);
    const landmarkHistoryRef = useRef<{ x: number; y: number }[][]>([]);
    const [noFaceDetectedDuration, setNoFaceDetectedDuration] = useState<number>(0);
    const [progress, setProgress] = useState<number>(0);
    const canvasRef = useRef<HTMLCanvasElement>(null);
    const offscreenCanvasRef = useRef<HTMLCanvasElement | null>(null);
    const displayVideoRef = useRef<HTMLVideoElement>(null);
    const animationFrameId = useRef<number | null>(null);
    const [makeupSuggestion, setMakeupSuggestion] = useState<any | null>(null);
    const lastDetectTime = useRef(0);
    const lastAnalysisTime = useRef(0);
    const lastRenderedLandmarks = useRef<NormalizedLandmark[] | null>(null);
    const faceFeaturesCache = useRef<FacialFeatures | null>(null);
    const lastHandDetectedTime = useRef<number>(0);
    const [currentFilter, setCurrentFilter] = useState<FilterType>("natural");
    const lastMakeupRender = useRef<number>(0);
    const MAKEUP_RENDER_INTERVAL = 50; // Gi·∫£m th·ªùi gian gi·ªØa c√°c l·∫ßn render ƒë·ªÉ l√†m m∆∞·ª£t h∆°n
    const lastRenderedFilter = useRef<FilterType>(currentFilter);
    const makeupImageRef = useRef<ImageData | null>(null);
    const stableImageCacheRef = useRef<ImageData | null>(null);
    const isRenderingRef = useRef<boolean>(false); // NgƒÉn render ƒë·ªìng th·ªùi
    const filterTransitionRef = useRef<boolean>(false); // ƒê√°nh d·∫•u ƒëang chuy·ªÉn filter
    const renderRequestRef = useRef<boolean>(false); // ƒê·ªÉ ƒë√°nh d·∫•u y√™u c·∫ßu render m·ªõi
    const lastRenderRequestTime = useRef<number>(0); // Th·ªùi ƒëi·ªÉm y√™u c·∫ßu render g·∫ßn nh·∫•t
    const landmarksToRender = useRef<NormalizedLandmark[] | null>(null); // L∆∞u landmarks c·∫ßn render
    
    // ƒê·∫∑t view khi component mount
    useEffect(() => {
        setCurrentView(VIEWS.COSMETIC_SURGERY);
        
        // T·∫°o offscreen canvas v·ªõi k√≠ch th∆∞·ªõc m·∫∑c ƒë·ªãnh ban ƒë·∫ßu
        if (!offscreenCanvasRef.current) {
            offscreenCanvasRef.current = document.createElement('canvas');
            offscreenCanvasRef.current.width = 640;
            offscreenCanvasRef.current.height = 480;
        }

        // ƒê·∫£m b·∫£o filter ƒë∆∞·ª£c l∆∞u khi component kh·ªüi t·∫°o
        lastRenderedFilter.current = currentFilter;

        return () => {
            // D·ªçn d·∫πp
            if (animationFrameId.current) {
                cancelAnimationFrame(animationFrameId.current);
            }
        };
    }, []);

    // Chu·∫©n b·ªã ƒë·ªëi t∆∞·ª£ng m√†u s·∫Øc filter cho c√°c ki·ªÉu l√†m ƒë·∫πp kh√°c nhau
    const filterColors = useMemo(() => ({
        natural: {
            lipColor: "rgba(223, 41, 41, 0.4)",
            lipHighlight: "rgba(255, 255, 255, 0.2)",
            cheekColor: "rgba(211, 34, 11, 0.3)",
            eyebrowColor: "rgba(54, 24, 15, 0.6)",
            eyelinerColor: "rgba(30, 30, 30, 0.8)",
            highlightColor: "rgba(255, 255, 255, 0.2)",
            contourColor: "rgba(80, 40, 40, 0.15)",
            skinColor: "rgba(197, 175, 163, 0.15)",
        },
        glamour: {
            lipColor: "rgba(190, 0, 50, 0.6)",
            lipHighlight: "rgba(255, 180, 180, 0.4)",
            cheekColor: "rgba(255, 20, 50, 0.35)",
            eyebrowColor: "rgba(20, 10, 0, 0.75)",
            eyelinerColor: "rgba(0, 0, 0, 0.95)",
            highlightColor: "rgba(255, 245, 230, 0.3)",
            contourColor: "rgba(60, 30, 30, 0.25)",
            skinColor: "rgba(255, 222, 200, 0.2)",
        },
        soft: {
            lipColor: "rgba(255, 150, 150, 0.4)",
            lipHighlight: "rgba(255, 255, 255, 0.25)",
            cheekColor: "rgba(255, 180, 180, 0.3)",
            eyebrowColor: "rgba(120, 90, 70, 0.5)",
            eyelinerColor: "rgba(90, 60, 60, 0.7)",
            highlightColor: "rgba(255, 255, 255, 0.25)",
            contourColor: "rgba(150, 120, 110, 0.1)",
            skinColor: "rgba(250, 240, 230, 0.2)",
        },
        dramatic: {
            lipColor: "rgba(150, 0, 40, 0.7)",
            lipHighlight: "rgba(255, 100, 100, 0.5)",
            cheekColor: "rgba(180, 40, 40, 0.4)",
            eyebrowColor: "rgba(10, 5, 0, 0.85)",
            eyelinerColor: "rgba(0, 0, 0, 1)",
            highlightColor: "rgba(255, 245, 220, 0.35)",
            contourColor: "rgba(40, 20, 20, 0.35)",
            skinColor: "rgba(240, 210, 190, 0.25)",
        },
        nude: {
            lipColor: "rgba(200, 150, 130, 0.5)",
            lipHighlight: "rgba(255, 240, 230, 0.3)",
            cheekColor: "rgba(210, 170, 140, 0.3)",
            eyebrowColor: "rgba(100, 80, 60, 0.6)",
            eyelinerColor: "rgba(80, 60, 50, 0.7)",
            highlightColor: "rgba(255, 250, 240, 0.25)",
            contourColor: "rgba(150, 120, 100, 0.2)",
            skinColor: "rgba(230, 220, 210, 0.2)",
        }
    }), []);

    // M√¥ t·∫£ cho t·ª´ng lo·∫°i filter
    const filterDescriptions = useMemo(() => ({
        natural: "T·ª± nhi√™n, nh·∫π nh√†ng t√¥n l√™n v·∫ª ƒë·∫πp v·ªën c√≥",
        glamour: "Quy·∫øn r≈©, n·ªïi b·∫≠t v·ªõi son ƒë·ªè v√† eyeliner ƒë·∫≠m",
        soft: "M·ªÅm m·∫°i, nh·∫π nh√†ng v·ªõi t√¥ng h·ªìng ph·∫•n",
        dramatic: "M·∫°nh m·∫Ω, ·∫•n t∆∞·ª£ng v·ªõi t√¥ng m√†u s√¢u", 
        nude: "T·ª± nhi√™n v·ªõi t√¥ng m√†u nude, ph√π h·ª£p h√†ng ng√†y"
    }), []);

    // Ph√¢n t√≠ch ƒë·∫∑c ƒëi·ªÉm khu√¥n m·∫∑t t·ª´ landmarks
    function analyzeFacialFeatures(landmarks: NormalizedLandmark[]): FacialFeatures {
        const euclidean = (a: any, b: any) =>
            Math.sqrt(Math.pow(a.x - b.x, 2) + Math.pow(a.y - b.y, 2));

        const leftEye = landmarks[33];
        const rightEye = landmarks[263];
        const jawLeft = landmarks[234];
        const jawRight = landmarks[454];
        const chin = landmarks[152];
        const forehead = landmarks[10];
        const noseLeft = landmarks[98];
        const noseRight = landmarks[327];
        const browLeft = landmarks[65];
        const browRight = landmarks[295];
        const cheekLeft = landmarks[50];
        const cheekRight = landmarks[280];

        const browCenter = {
            x: (browLeft.x + browRight.x) / 2,
            y: (browLeft.y + browRight.y) / 2,
        };
        const faceWidth = euclidean(jawLeft, jawRight);
        const faceHeight = euclidean(chin, forehead);
        const eyeDistance = euclidean(leftEye, rightEye);
        const noseWidth = euclidean(noseLeft, noseRight);
        const lipWidth = euclidean(landmarks[61], landmarks[291]);
        const browLength = euclidean(browLeft, browRight);
        const cheekboneProminence = euclidean(cheekLeft, cheekRight);
        const foreheadHeight = euclidean(forehead, browCenter);
        const cheekboneHeight =
            euclidean(cheekLeft, leftEye) / euclidean(chin, cheekLeft);

        let faceShape: FacialFeatures["faceShape"] = "oval";
        const ratio = faceHeight / faceWidth;
        if (ratio > 1.5) faceShape = "long";
        else if (ratio > 1.3) faceShape = "oval";
        else if (ratio < 1.1) faceShape = "square";
        else if (cheekboneProminence > faceWidth * 0.9) faceShape = "heart";
        else faceShape = "round";

        return {
            eyeDistance,
            faceWidth,
            faceHeight,
            noseWidth,
            lipWidth,
            browLength,
            cheekboneProminence,
            faceShape,
            cheekboneHeight,
            foreheadHeight,
        };
    }

    // T·∫°o g·ª£i √Ω makeup d·ª±a tr√™n ƒë·∫∑c ƒëi·ªÉm khu√¥n m·∫∑t
    function generateMakeupSuggestion(features: FacialFeatures): string {
        const suggestions: string[] = [];

        // Th√™m m√¥ t·∫£ filter hi·ªán t·∫°i
        suggestions.push(
            `<div style="margin-bottom: 10px; padding: 10px; background: rgba(255,182,193,0.2); border-radius: 8px;">
                <strong style="font-size: 1em; color: #d64161;">üíÑ Filter hi·ªán t·∫°i: ${currentFilter.charAt(0).toUpperCase() + currentFilter.slice(1)}</strong>
                <p style="margin: 5px 0 0; font-size: 0.9em;">${filterDescriptions[currentFilter]}</p>
            </div>`
        );

        // Nh·∫≠n x√©t h√¨nh d√°ng khu√¥n m·∫∑t
        switch (features.faceShape) {
            case "round":
                suggestions.push(
                    `<strong style="font-size: 0.88em;">üìê Khu√¥n m·∫∑t c·ªßa b·∫°n tr√≤n v·ªõi ƒë∆∞·ªùng n√©t m·ªÅm m·∫°i</strong> <br/><em style="font-size: 17px;">üíÑ N√™n t·∫°o kh·ªëi nh·∫π ·ªü hai b√™n m√° v√† x∆∞∆°ng h√†m ƒë·ªÉ t·∫°o c·∫£m gi√°c thon g·ªçn</em>`
                );
                break;
            case "oval":
                suggestions.push(
                    `<strong style="font-size: 0.88em;">üìê Khu√¥n m·∫∑t c·ªßa b·∫°n h√¨nh oval, t·ªâ l·ªá r·∫•t c√¢n ƒë·ªëi</strong> <br/>üíÑ<em style="font-size: 17px;"> Ch·ªâ c·∫ßn nh·∫•n nh·∫π v√†o c√°c ƒë∆∞·ªùng n√©t ƒë·ªÉ t√¥n l√™n v·∫ª ƒë·∫πp t·ª± nhi√™n </em>`
                );
                break;
            case "square":
                suggestions.push(
                    `<strong style="font-size: 0.88em;">üìê Khu√¥n m·∫∑t c·ªßa b·∫°n vu√¥ng v·ªõi ƒë∆∞·ªùng h√†m r√µ n√©t</strong> <br/>üíÑ<em style="font-size: 17px;"> H√£y d√πng highlight ·ªü tr√°n v√† c·∫±m ƒë·ªÉ l√†m m·ªÅm ƒë∆∞·ªùng n√©t khu√¥n m·∫∑t</em>`
                );
                break;
            case "heart":
                suggestions.push(
                    `<strong style="font-size: 0.88em;">üìê Khu√¥n m·∫∑t b·∫°n h√¨nh tr√°i tim, tr√°n r·ªông, c·∫±m nh·ªè</strong> <br/>üíÑ<em style="font-size: 17px;"> N√™n t·∫≠p trung highlight v√πng tr√°n v√† t·∫°o kh·ªëi nh·∫π cho ph·∫ßn c·∫±m</em>`
                );
                break;
            case "long":
                suggestions.push(
                    `<strong style="font-size: 0.88em;">üìê Khu√¥n m·∫∑t b·∫°n kh√° d√†i, thanh tho√°t</strong> <br/>üíÑ<em style="font-size: 17px;"> D√πng m√° h·ªìng t√°n ngang ƒë·ªÉ gi√∫p khu√¥n m·∫∑t tr√¥ng c√¢n ƒë·ªëi h∆°n</em>`
                );
                break;
        }

        // Kho·∫£ng c√°ch m·∫Øt
        if (features.eyeDistance > 0.15) {
            suggestions.push(
                `<strong style="font-size: 0.88em;">üëÅÔ∏è ƒê√¥i m·∫Øt b·∫°n kh√° to v√† c√°ch xa nhau</strong> <br/>üíÑ<em style="font-size: 17px;"> N√™n k·∫ª eyeliner ƒë·∫≠m v√† chu·ªët mascara k·ªπ ph·∫ßn kh√≥e m·∫Øt trong ƒë·ªÉ thu h·∫πp kho·∫£ng c√°ch</em>`
            );
        } else {
            suggestions.push(
                `<strong style="font-size: 0.88em;">üëÅÔ∏è ƒê√¥i m·∫Øt b·∫°n nh·ªè ho·∫∑c g·∫ßn nhau</strong> <br/>üíÑ<em style="font-size: 17px;">∆Øu ti√™n eyeliner m·∫£nh v√† ph·∫•n m·∫Øt s√°ng ƒë·ªÉ m·ªü r·ªông ƒë√¥i m·∫Øt</em>`
            );
        }

        // M√¥i
        if (features.lipWidth > 0.15) {
            suggestions.push(
                `<strong style="font-size: 0.88em;">üëÑ B·∫°n c√≥ ƒë√¥i m√¥i ƒë·∫ßy ƒë·∫∑n </strong><br/> üíÑ<em style="font-size: 17px;"> H√£y d√πng son l√¨ ho·∫∑c m√†u tr·∫ßm ƒë·ªÉ t·∫°o c·∫£m gi√°c h√†i h√≤a h∆°n.</em>`
            );
        } else {
            suggestions.push(
                `<strong style="font-size: 0.88em;">üëÑ M√¥i b·∫°n kh√° nh·ªè g·ªçn </strong><br/> üíÑ<em style="font-size: 17px;"> S·ª≠ d·ª•ng son b√≥ng ho·∫∑c t√¥ng m√†u t∆∞∆°i s√°ng ƒë·ªÉ gi√∫p m√¥i tr√¥ng cƒÉng m·ªçng h∆°n.</em>`
            );
        }

        // M≈©i
        if (features.noseWidth > 0.07) {
            suggestions.push(
                `<strong style="font-size: 0.88em;">üëÉ M≈©i c·ªßa b·∫°n h∆°i r·ªông </strong><br/> üíÑ<em style="font-size: 17px;"> T·∫°o kh·ªëi nh·∫π hai b√™n s·ªëng m≈©i ƒë·ªÉ t·∫°o hi·ªáu ·ª©ng thon g·ªçn.</em>`
            );
        } else {
            suggestions.push(
                `<strong style="font-size: 0.88em;">üëÉ M≈©i b·∫°n thon g·ªçn </strong><br/> üíÑ<em style="font-size: 17px;"> H√£y t√¥ ch√∫t highlight d·ªçc s·ªëng m≈©i ƒë·ªÉ tƒÉng chi·ªÅu s√¢u v√† n·ªïi b·∫≠t.</em>`
            );
        }

        // L√¥ng m√†y
        if (features.browLength < features.eyeDistance * 1.5) {
            suggestions.push(
                `<strong style="font-size: 0.88em;">üëÅÔ∏è‚Äçüó®Ô∏è L√¥ng m√†y b·∫°n ng·∫Øn v√† nh·∫π </strong><br/> üíÑ<em style="font-size: 17px;"> N√™n k·∫ª d√†i th√™m m·ªôt ch√∫t v√† t·∫°o ƒë·ªô cong nh·∫π ƒë·ªÉ g∆∞∆°ng m·∫∑t h√†i h√≤a h∆°n.</em>`
            );
        } else {
            suggestions.push(
                `<strong style="font-size: 0.88em;">üëÅÔ∏è‚Äçüó®Ô∏è L√¥ng m√†y b·∫°n kh√° d√†i v√† r√µ n√©t </strong><br/> üíÑ<em style="font-size: 17px;"> Ch·ªâ c·∫ßn gi·ªØ d√°ng t·ª± nhi√™n, kh√¥ng n√™n t√¥ qu√° s·∫Øc ƒë·ªÉ tr√°nh l√†m khu√¥n m·∫∑t c·ª©ng.</em>`
            );
        }

        // G√≤ m√°
        if (features.cheekboneHeight < 0.4) {
            suggestions.push(
                `<strong style="font-size: 0.88em;">üòä G√≤ m√° b·∫°n cao </strong><br/> üíÑ<em style="font-size: 17px;"> H√£y ƒë√°nh m√° h·ªìng th·∫•p h∆°n x∆∞∆°ng g√≤ m√° v√† t√°n ngang ƒë·ªÉ l√†m d·ªãu ƒë∆∞·ªùng n√©t.</em>`
            );
        } else {
            suggestions.push(
                `<strong style="font-size: 0.88em;">üòä G√≤ m√° b·∫°n th·∫•p </strong><br/> üíÑ<em style="font-size: 17px;"> N√™n t√°n m√° h·ªìng cao v√† k√©o d√†i l√™n th√°i d∆∞∆°ng ƒë·ªÉ t·∫°o hi·ªáu ·ª©ng n√¢ng m·∫∑t.</em>`
            );
        }

        // ƒê∆∞·ªùng ch√¢n t√≥c
        if (features.foreheadHeight > 0.15) {
            suggestions.push(
                `<strong style="font-size: 0.88em;">üîç Tr√°n b·∫°n cao </strong><br/> üíÑ<em style="font-size: 17px;"> D√πng ph·∫•n t·ªëi m√†u s√°t ch√¢n t√≥c ƒë·ªÉ t·∫°o c·∫£m gi√°c tr√°n th·∫•p h∆°n v√† m·ªÅm m·∫°i h∆°n.</em>`
            );
        } else {
            suggestions.push(
                `<strong style="font-size: 0.88em;">üîç Tr√°n b·∫°n th·∫•p </strong><br/> üíÑ<em style="font-size: 17px;"> C√≥ th·ªÉ ch·∫£i t√≥c ra sau ho·∫∑c highlight v√πng tr√°n ƒë·ªÉ khu√¥n m·∫∑t c√¢n ƒë·ªëi h∆°n.</em>`
            );
        }

        // Th√™m UI l·ª±a ch·ªçn filter v·ªõi n√∫t nh·∫•n
        suggestions.push(`
            <div style="margin-top: 15px; padding: 10px; background: rgba(255,182,193,0.1); border-radius: 8px;">
                <strong style="font-size: 0.9em;">üé® Th·ª≠ c√°c phong c√°ch makeup kh√°c:</strong>
                <div style="display: flex; flex-wrap: wrap; gap: 10px; margin-top: 8px;">
                    <button data-filter="natural" style="padding: 8px 12px; border-radius: 20px; border: none; background: ${currentFilter === 'natural' ? '#d64161' : '#f8d0d8'}; color: ${currentFilter === 'natural' ? 'white' : '#333'}; cursor: pointer; font-size: 14px;">T·ª± nhi√™n</button>
                    <button data-filter="glamour" style="padding: 8px 12px; border-radius: 20px; border: none; background: ${currentFilter === 'glamour' ? '#d64161' : '#f8d0d8'}; color: ${currentFilter === 'glamour' ? 'white' : '#333'}; cursor: pointer; font-size: 14px;">Quy·∫øn r≈©</button>
                    <button data-filter="soft" style="padding: 8px 12px; border-radius: 20px; border: none; background: ${currentFilter === 'soft' ? '#d64161' : '#f8d0d8'}; color: ${currentFilter === 'soft' ? 'white' : '#333'}; cursor: pointer; font-size: 14px;">M·ªÅm m·∫°i</button>
                    <button data-filter="dramatic" style="padding: 8px 12px; border-radius: 20px; border: none; background: ${currentFilter === 'dramatic' ? '#d64161' : '#f8d0d8'}; color: ${currentFilter === 'dramatic' ? 'white' : '#333'}; cursor: pointer; font-size: 14px;">·∫§n t∆∞·ª£ng</button>
                    <button data-filter="nude" style="padding: 8px 12px; border-radius: 20px; border: none; background: ${currentFilter === 'nude' ? '#d64161' : '#f8d0d8'}; color: ${currentFilter === 'nude' ? 'white' : '#333'}; cursor: pointer; font-size: 14px;">Nude</button>
                </div>
            </div>
        `);

        return suggestions.join("<br/>");
    }

    // K·∫øt n·ªëi video stream
    useEffect(() => {
        if (stream && displayVideoRef.current) {
            displayVideoRef.current.srcObject = stream;
            displayVideoRef.current.onloadedmetadata = () => {
                displayVideoRef.current!.play().catch((err: any) => {
                    console.error("[PersonalMakeup] Error playing video:", err);
                });
                setIsVideoReady(true);
                
                // C·∫≠p nh·∫≠t k√≠ch th∆∞·ªõc offscreen canvas khi video ƒë√£ s·∫µn s√†ng
                if (offscreenCanvasRef.current && displayVideoRef.current) {
                    offscreenCanvasRef.current.width = displayVideoRef.current.videoWidth;
                    offscreenCanvasRef.current.height = displayVideoRef.current.videoHeight;
                }
                
                // C·∫≠p nh·∫≠t k√≠ch th∆∞·ªõc canvas ch√≠nh khi video ƒë√£ s·∫µn s√†ng
                if (canvasRef.current && displayVideoRef.current) {
                    canvasRef.current.width = displayVideoRef.current.videoWidth;
                    canvasRef.current.height = displayVideoRef.current.videoHeight;
                }
                
                setIsLoading(false);
                setStatusMessage("Please keep your face steady for analysis");
                setProgress(20);
            };
        }
    }, [stream, setIsLoading]);

    // X·ª≠ l√Ω s·ª± ki·ªán b·∫•m n√∫t ch·ªçn filter
    useEffect(() => {
        // Th√™m event listener ƒë·ªÉ ph√°t hi·ªán khi ng∆∞·ªùi d√πng nh·∫•n n√∫t ch·ªçn filter
        const handleFilterClick = (e: MouseEvent) => {
            const target = e.target as HTMLElement;
            if (target.tagName === 'BUTTON' && target.dataset.filter) {
                const filterName = target.dataset.filter as FilterType;
                
                // N·∫øu ƒëang ch·ªçn filter hi·ªán t·∫°i, kh√¥ng l√†m g√¨ c·∫£
                if (filterName === currentFilter) return;
                
                // ƒê√°nh d·∫•u ƒëang trong qu√° tr√¨nh chuy·ªÉn filter
                filterTransitionRef.current = true;
                
                // X√≥a cache makeup ƒë·ªÉ bu·ªôc v·∫Ω l·∫°i
                makeupImageRef.current = null;
                
                // C·∫≠p nh·∫≠t filter m·ªõi
                setCurrentFilter(filterName);
                
                // L∆∞u filter m·ªõi ngay l·∫≠p t·ª©c v√†o ref
                lastRenderedFilter.current = filterName;
                
                // Y√™u c·∫ßu render ngay
                renderRequestRef.current = true;
                lastRenderRequestTime.current = performance.now();
                
                // C·∫≠p nh·∫≠t l·∫°i g·ª£i √Ω makeup n·∫øu c√≥ ƒë·∫∑c ƒëi·ªÉm khu√¥n m·∫∑t
                if (faceFeaturesCache.current) {
                    const suggestion = generateMakeupSuggestion(faceFeaturesCache.current);
                    setMakeupSuggestion(suggestion);
                }
                
                // K·∫øt th√∫c qu√° tr√¨nh chuy·ªÉn filter sau 300ms
                setTimeout(() => {
                    filterTransitionRef.current = false;
                }, 300);
            }
        };
        
        document.addEventListener('click', handleFilterClick);
        
        return () => {
            document.removeEventListener('click', handleFilterClick);
        };
    }, [currentFilter]);

    // C·∫£i ti·∫øn h√†m ki·ªÉm tra ·ªïn ƒë·ªãnh frame v·ªõi thu·∫≠t to√°n ch·ªëng nh·∫•p nh√°y
    const checkFrameStability = useCallback((landmarks: { x: number; y: number }[]) => {
        const now = performance.now();
        
        // N·∫øu ƒëang trong qu√° tr√¨nh chuy·ªÉn filter, xem nh∆∞ frame ·ªïn ƒë·ªãnh
        if (filterTransitionRef.current) {
            return true; // Tr·∫£ v·ªÅ true ƒë·ªÉ cho bi·∫øt frame ·ªïn ƒë·ªãnh
        }
        
        // N·∫øu ph√°t hi·ªán tay, l∆∞u l·∫°i tr·∫°ng th√°i tr∆∞·ªõc ƒë√≥ nh∆∞ng kh√¥ng thay ƒë·ªïi tr·∫°ng th√°i hi·ªán t·∫°i
        if (handData.isHandDetected) {
            // L∆∞u th·ªùi gian ph√°t hi·ªán tay
            lastHandDetectedTime.current = now;
            return isFrameStable; // Gi·ªØ nguy√™n tr·∫°ng th√°i ·ªïn ƒë·ªãnh hi·ªán t·∫°i
        }
        
        // Ki·ªÉm tra xem c√≥ face landmarks kh√¥ng
        if (!detectionResults.face?.faceLandmarks) {
            setNoFaceDetectedDuration((prev) => prev + 1000);
            if (noFaceDetectedDuration >= 30000) {
                setStatusMessage("Face not detected for a long time. Please refresh the camera.");
            } else {
                setStatusMessage("Face not detected. Please adjust your position.");
                setPrevStatusMessage("Face not detected. Please adjust your position.");
            }
            setProgress(0);
            setIsFrameStable(false);
            landmarkHistoryRef.current = []; // reset
            return false;
        }
    
        setNoFaceDetectedDuration(0);
    
        // Th√™m landmarks v√†o l·ªãch s·ª≠ v√† gi·ªõi h·∫°n k√≠ch th∆∞·ªõc
        const newHistory = [...landmarkHistoryRef.current, landmarks].slice(-HISTORY_SIZE);
    
        if (newHistory.length < HISTORY_SIZE) {
            setStatusMessage("Collecting face data...");
            setPrevStatusMessage("Collecting face data...");
            setProgress(20);
            landmarkHistoryRef.current = newHistory;
            return false;
        }
    
        // T√≠nh to√°n ƒë·ªô l·ªách trung b√¨nh gi·ªØa c√°c frame li√™n ti·∫øp - t·ªëi ∆∞u h√≥a
        let totalDeviation = 0;
        
        // Ch·ªâ ki·ªÉm tra m·ªôt s·ªë ƒëi·ªÉm quan tr·ªçng ƒë·ªÉ tƒÉng hi·ªáu su·∫•t
        const keyPointIndices = [8, 33, 263, 61, 291]; // M≈©i, m·∫Øt, m√¥i
        
        for (let i = 1; i < newHistory.length; i++) {
            for (const idx of keyPointIndices) {
                if (idx < landmarks.length) {
                    const dx = (newHistory[i][idx].x - newHistory[i - 1][idx].x) * 640;
                    const dy = (newHistory[i][idx].y - newHistory[i - 1][idx].y) * 480;
                    totalDeviation += Math.sqrt(dx * dx + dy * dy);
                }
            }
        }
    
        const averageDeviation = totalDeviation / (keyPointIndices.length * (newHistory.length - 1));
        
        // Th√™m hysteresis ƒë·ªÉ tr√°nh tr·∫°ng th√°i nh·∫•p nh√°y
        const isCurrentlyStable = isFrameStable;
        const isStable = isCurrentlyStable 
            ? averageDeviation < (STABILITY_THRESHOLD * 1.2)  // C·∫ßn l·ªách nhi·ªÅu h∆°n ƒë·ªÉ m·∫•t ·ªïn ƒë·ªãnh
            : averageDeviation < (STABILITY_THRESHOLD * 0.8); // C·∫ßn l·ªách √≠t h∆°n ƒë·ªÉ tr·ªü n√™n ·ªïn ƒë·ªãnh
        
        // X·ª≠ l√Ω logic tr·∫°ng th√°i ·ªïn ƒë·ªãnh
        if (isStable && !lastStableTime.current) {
            // Chuy·ªÉn sang tr·∫°ng th√°i ·ªïn ƒë·ªãnh
            lastStableTime.current = now;
            setStatusMessage("Analyzing face...");
            setPrevStatusMessage("Analyzing face...");
            setProgress(60);
        } else if (isStable && lastStableTime.current && now - lastStableTime.current >= STABILITY_DURATION) {
            // X√°c nh·∫≠n ƒë√£ ·ªïn ƒë·ªãnh ƒë·ªß l√¢u
            if (!isFrameStable) {
                setIsFrameStable(true);
                setStatusMessage("Analysis completed!");
                setPrevStatusMessage("Analysis completed!");
                setProgress(100);
            }
            lastUnstableTime.current = null;
        } else if (!isStable) {
            // N·∫øu kh√¥ng ·ªïn ƒë·ªãnh nh∆∞ng m·ªõi ch·ªâ ·ªïn ƒë·ªãnh trong m·ªôt th·ªùi gian ng·∫Øn, b·ªè qua
            if (lastStableTime.current && now - lastStableTime.current < MIN_STABLE_DURATION) {
                landmarkHistoryRef.current = newHistory;
                return false;
            }
            
            // X√°c nh·∫≠n ƒë√£ kh√¥ng ·ªïn ƒë·ªãnh
            if (!lastUnstableTime.current) {
                lastUnstableTime.current = now;
            }
            
            // Ch·ªâ chuy·ªÉn sang tr·∫°ng th√°i kh√¥ng ·ªïn ƒë·ªãnh n·∫øu ƒë√£ kh√¥ng ·ªïn ƒë·ªãnh ƒë·ªß l√¢u
            if (lastUnstableTime.current && now - lastUnstableTime.current > 300) {
                lastStableTime.current = null;
                setIsFrameStable(false);
                setStatusMessage("Please keep your face steady for analysis");
                setPrevStatusMessage("Please keep your face steady for analysis");
                setProgress(20);
            }
        }
    
        landmarkHistoryRef.current = newHistory;
        return isStable;
    }, [
        HISTORY_SIZE,
        STABILITY_THRESHOLD,
        STABILITY_DURATION,
        MIN_STABLE_DURATION,
        detectionResults,
        noFaceDetectedDuration,
        handData.isHandDetected,
        isFrameStable
    ]);

    // ƒê∆∞·ª£c t·ªëi ∆∞u l·∫°i ƒë·ªÉ gi·∫£m nh·∫•p nh√°y
    function drawMakeup(
        ctx: CanvasRenderingContext2D,
        landmarks: NormalizedLandmark[],
        width: number,
        height: number,
        forceRender: boolean = false
    ) {
        // NgƒÉn render ƒë·ªìng th·ªùi
        if (isRenderingRef.current && !forceRender) {
            return;
        }
        
        const now = performance.now();
        isRenderingRef.current = true;
        
        try {
            // Ki·ªÉm tra xem filter c√≥ thay ƒë·ªïi so v·ªõi l·∫ßn render tr∆∞·ªõc kh√¥ng
            const filterChanged = lastRenderedFilter.current !== currentFilter;
            
            // C·∫≠p nh·∫≠t filter hi·ªán t·∫°i
            if (filterChanged) {
                console.log(`Filter changed from ${lastRenderedFilter.current} to ${currentFilter}`);
                lastRenderedFilter.current = currentFilter;
                // B·∫Øt bu·ªôc v·∫Ω l·∫°i khi filter thay ƒë·ªïi
                makeupImageRef.current = null;
            }
            
            // N·∫øu ƒë√£ c√≥ cache v√† ch∆∞a ƒë·∫øn th·ªùi ƒëi·ªÉm v·∫Ω l·∫°i v√† kh√¥ng c√≥ y√™u c·∫ßu render m·ªõi, s·ª≠ d·ª•ng cache
            if (makeupImageRef.current && 
                !filterChanged && 
                !forceRender && 
                !renderRequestRef.current && 
                now - lastMakeupRender.current < MAKEUP_RENDER_INTERVAL) {
                ctx.putImageData(makeupImageRef.current, 0, 0);
                isRenderingRef.current = false;
                return;
            }
            
            // Reset y√™u c·∫ßu render n·∫øu c√≥
            if (renderRequestRef.current) {
                renderRequestRef.current = false;
            }
            
            // C·∫≠p nh·∫≠t th·ªùi gian render cu·ªëi c√πng
            lastMakeupRender.current = now;
            
            // N·∫øu kh√¥ng ·ªïn ƒë·ªãnh v√† c√≥ cache ·ªïn ƒë·ªãnh tr∆∞·ªõc ƒë√≥, s·ª≠ d·ª•ng cache ƒë√≥
            if (!isFrameStable && stableImageCacheRef.current && !forceRender) {
                ctx.putImageData(stableImageCacheRef.current, 0, 0);
                isRenderingRef.current = false;
                return;
            }
            
            // ƒê·∫£m b·∫£o offscreen canvas t·ªìn t·∫°i v√† c√≥ k√≠ch th∆∞·ªõc ph√π h·ª£p
            if (!offscreenCanvasRef.current) {
                offscreenCanvasRef.current = document.createElement('canvas');
                offscreenCanvasRef.current.width = width;
                offscreenCanvasRef.current.height = height;
            } else if (offscreenCanvasRef.current.width !== width || offscreenCanvasRef.current.height !== height) {
                offscreenCanvasRef.current.width = width;
                offscreenCanvasRef.current.height = height;
            }
            
            const offscreenCtx = offscreenCanvasRef.current.getContext('2d', { willReadFrequently: true });
            if (!offscreenCtx) {
                isRenderingRef.current = false;
                return;
            }
            
            // X√≥a offscreen canvas
            offscreenCtx.clearRect(0, 0, width, height);
            
            // L·∫•y m√†u t·ª´ filter hi·ªán t·∫°i
            const colors = filterColors[currentFilter];
            
            // L·∫•y c√°c ƒëi·ªÉm ƒë√°nh d·∫•u cho m√¥i
            const outerLip = [61, 146, 91, 181, 84, 17, 314, 405, 321, 375, 291];
            const innerLip = [78, 95, 88, 178, 87, 14, 317, 402, 318, 324, 308];
        
            // V·∫Ω m√¥i
            offscreenCtx.save();
            offscreenCtx.filter = "blur(5px)";
        
            // V·∫Ω n·ªÅn m√¥i
            offscreenCtx.beginPath();
            offscreenCtx.fillStyle = colors.lipColor;
            outerLip.forEach((index, i) => {
                const pt = landmarks[index];
                const x = pt.x * width;
                const y = pt.y * height;
                if (i === 0) offscreenCtx.moveTo(x, y);
                else offscreenCtx.lineTo(x, y);
            });
            offscreenCtx.closePath();
            offscreenCtx.fill();
        
            // Gradient hi·ªáu ·ª©ng b√≥ng (trong l√≤ng m√¥i)
            const gradient = offscreenCtx.createRadialGradient(
                landmarks[13].x * width,
                landmarks[13].y * height,
                1,
                landmarks[13].x * width,
                landmarks[13].y * height,
                width * 0.05
            );
            gradient.addColorStop(0, colors.lipHighlight);
            gradient.addColorStop(1, "rgba(230, 71, 145, 0)");
        
            offscreenCtx.beginPath();
            offscreenCtx.fillStyle = gradient;
            outerLip.forEach((index, i) => {
                const pt = landmarks[index];
                const x = pt.x * width;
                const y = pt.y * height;
                if (i === 0) offscreenCtx.moveTo(x, y);
                else offscreenCtx.lineTo(x, y);
            });
            offscreenCtx.closePath();
            offscreenCtx.fill();
        
            // Kho√©t ph·∫ßn m√¥i trong ƒë·ªÉ t·∫°o ƒë·ªô d√†y
            offscreenCtx.globalCompositeOperation = "destination-out";
            offscreenCtx.beginPath();
            innerLip.forEach((index, i) => {
                const pt = landmarks[index];
                const x = pt.x * width;
                const y = pt.y * height;
                if (i === 0) offscreenCtx.moveTo(x, y);
                else offscreenCtx.lineTo(x, y);
            });
            offscreenCtx.closePath();
            offscreenCtx.fill();
        
            offscreenCtx.globalCompositeOperation = "source-over";
            offscreenCtx.restore();
        
            // V·∫Ω m√° h·ªìng
            const leftCheekPoint = landmarks[50];
            const rightCheekPoint = landmarks[280];
        
            // T·ªça ƒë·ªô th·ª±c c·ªßa g√≤ m√°
            const leftX = leftCheekPoint.x * width;
            const leftY = leftCheekPoint.y * height;
            const rightX = rightCheekPoint.x * width;
            const rightY = rightCheekPoint.y * height;
        
            offscreenCtx.save();
            offscreenCtx.filter = "blur(7px)";
            offscreenCtx.fillStyle = colors.cheekColor;
        
            // ƒêi·ªÅu ch·ªânh ƒë·ªô l·ªõn m√° h·ªìng theo ki·ªÉu filter
            let radius;
            switch (currentFilter) {
                case 'glamour':
                    radius = Math.min(width, height) * 0.022;
                    break;
                case 'soft':
                    radius = Math.min(width, height) * 0.025;
                    break;
                case 'dramatic':
                    radius = Math.min(width, height) * 0.02;
                    break;
                case 'nude':
                    radius = Math.min(width, height) * 0.019;
                    break;
                default:
                    radius = Math.min(width, height) * 0.018;
            }
        
            // M√° tr√°i
            offscreenCtx.beginPath();
            offscreenCtx.arc(leftX, leftY, radius, 0, Math.PI * 2);
            offscreenCtx.fill();
        
            // M√° ph·∫£i
            offscreenCtx.beginPath();
            offscreenCtx.arc(rightX, rightY, radius, 0, Math.PI * 2);
            offscreenCtx.fill();
        
            offscreenCtx.restore();
        
            // V·∫Ω l√¥ng m√†y
            const leftEyebrow = [70, 63, 105, 66, 107];
            const rightEyebrow = [336, 296, 334, 293, 300];
        
            offscreenCtx.save();
            offscreenCtx.filter = "blur(3px)";
            offscreenCtx.fillStyle = colors.eyebrowColor;
            
            // L√¥ng m√†y tr√°i
            offscreenCtx.beginPath();
            leftEyebrow.forEach((index, i) => {
                const pt = landmarks[index];
                const x = pt.x * width;
                const y = pt.y * height;
                if (i === 0) offscreenCtx.moveTo(x, y);
                else offscreenCtx.lineTo(x, y);
            });
            offscreenCtx.closePath();
            offscreenCtx.fill();
            
            // L√¥ng m√†y ph·∫£i
            offscreenCtx.beginPath();
            rightEyebrow.forEach((index, i) => {
                const pt = landmarks[index];
                const x = pt.x * width;
                const y = pt.y * height;
                if (i === 0) offscreenCtx.moveTo(x, y);
                else offscreenCtx.lineTo(x, y);
            });
            offscreenCtx.closePath();
            offscreenCtx.fill();
            offscreenCtx.restore();
            
            // V·∫Ω s·ªëng m≈©i v√† v√πng highlight
            const noseBridge = [6, 197, 195, 5, 4];
            const noseContourLeft = [98, 327, 326];
            const noseContourRight = [327, 326, 98].map((i) => 454 - i);
        
            // Highlight s·ªëng m≈©i
            offscreenCtx.save();
            offscreenCtx.filter = "blur(5px)";
            offscreenCtx.beginPath();
            offscreenCtx.fillStyle = colors.highlightColor;
            noseBridge.forEach((index, i) => {
                const pt = landmarks[index];
                const x = pt.x * width;
                const y = pt.y * height;
                if (i === 0) offscreenCtx.moveTo(x, y);
                else offscreenCtx.lineTo(x, y);
            });
            offscreenCtx.stroke();
            offscreenCtx.restore();
        
            // Shadow 2 b√™n c√°nh m≈©i (contour)
            const drawSideShadow = (points: number[]) => {
                offscreenCtx.save();
                offscreenCtx.filter = "blur(4px)";
                offscreenCtx.beginPath();
                offscreenCtx.fillStyle = colors.contourColor;
                points.forEach((index, i) => {
                    const pt = landmarks[index];
                    const x = pt.x * width;
                    const y = pt.y * height;
                    if (i === 0) offscreenCtx.moveTo(x, y);
                    else offscreenCtx.lineTo(x, y);
                });
                offscreenCtx.closePath();
                offscreenCtx.fill();
                offscreenCtx.restore();
            };
        
            drawSideShadow(noseContourLeft);
            drawSideShadow(noseContourRight);
        
            // V·∫Ω eyeliner
            const leftEyeliner = [33, 7, 163, 144, 145, 153, 154, 155];
            const rightEyeliner = [263, 249, 390, 373, 374, 380, 381, 382];
        
            const drawEyeliner = (indices: number[], color: string) => {
                offscreenCtx.save();
                offscreenCtx.beginPath();
                offscreenCtx.strokeStyle = color;
                
                // ƒêi·ªÅu ch·ªânh ƒë·ªô d√†y eyeliner theo ki·ªÉu filter
                switch (currentFilter) {
                    case 'glamour':
                        offscreenCtx.lineWidth = 1.5;
                        break;
                    case 'dramatic':
                        offscreenCtx.lineWidth = 2;
                        break;
                    case 'soft':
                    case 'nude':
                        offscreenCtx.lineWidth = 0.8;
                        break;
                    default:
                        offscreenCtx.lineWidth = 1;
                }
                
                offscreenCtx.lineJoin = "round";
                offscreenCtx.lineCap = "round";
        
                indices.forEach((index, i) => {
                    const pt = landmarks[index];
                    const x = pt.x * width;
                    const y = pt.y * height;
                    if (i === 0) offscreenCtx.moveTo(x, y);
                    else offscreenCtx.lineTo(x, y);
                });
        
                offscreenCtx.stroke();
                offscreenCtx.restore();
            };
        
            // Eyeliner
            drawEyeliner(leftEyeliner, colors.eyelinerColor);
            drawEyeliner(rightEyeliner, colors.eyelinerColor);
        
            // V·∫Ω ph·∫•n m·∫Øt cho m·ªôt s·ªë ki·ªÉu
            if (['glamour', 'dramatic', 'soft'].includes(currentFilter)) {
                const drawEyeShadow = (eye: number[]) => {
                    offscreenCtx.save();
                    offscreenCtx.filter = "blur(8px)";
                    offscreenCtx.beginPath();
                    
                    // Ch·ªçn m√†u ph·∫•n m·∫Øt theo ki·ªÉu
                    let shadowColor;
                    switch (currentFilter) {
                        case 'glamour':
                            shadowColor = "rgba(120, 60, 60, 0.3)";
                            break;
                        case 'dramatic':
                            shadowColor = "rgba(80, 40, 60, 0.4)";
                            break;
                        case 'soft':
                            shadowColor = "rgba(200, 160, 180, 0.25)";
                            break;
                        default:
                            shadowColor = "rgba(150, 120, 120, 0.2)";
                    }
                    
                    offscreenCtx.fillStyle = shadowColor;
                    eye.forEach((index, i) => {
                        const pt = landmarks[index];
                        const x = pt.x * width;
                        const y = pt.y * height;
                        if (i === 0) offscreenCtx.moveTo(x, y);
                        else offscreenCtx.lineTo(x, y);
                    });
                    offscreenCtx.closePath();
                    offscreenCtx.fill();
                    offscreenCtx.restore();
                };
                
                const leftEyeShadow = [33, 7, 163, 144, 145, 153, 154, 155, 33];
                const rightEyeShadow = [263, 249, 390, 373, 374, 380, 381, 382, 263];
                
                drawEyeShadow(leftEyeShadow);
                drawEyeShadow(rightEyeShadow);
            }
        
            // Da tr·∫Øng s√°ng
            const faceOutline = [
                10, 338, 297, 332, 284, 251, 389, 356, 454, 323, 361, 288, 397, 365,
                379, 378, 400, 377, 152, 148, 176, 149, 150, 136, 172, 58, 132, 93,
                234, 127, 162, 21, 54,
            ];
        
            offscreenCtx.save();
            offscreenCtx.beginPath();
            faceOutline.forEach((index, i) => {
                const pt = landmarks[index];
                const x = pt.x * width;
                const y = pt.y * height;
                if (i === 0) offscreenCtx.moveTo(x, y);
                else offscreenCtx.lineTo(x, y);
            });
            offscreenCtx.closePath();
        
            // T√¥ m√†u da + blur
            offscreenCtx.filter = "blur(6px)";
            offscreenCtx.fillStyle = colors.skinColor;
            offscreenCtx.fill();
            offscreenCtx.restore();
            
            // Th√™m hi·ªáu ·ª©ng ƒëi·ªÉm nh·∫•n ri√™ng cho t·ª´ng ki·ªÉu filter
            if (currentFilter === 'glamour' || currentFilter === 'dramatic') {
                // Th√™m highlight cho ƒë∆∞·ªùng g√≤ m√°
                const cheekboneLeft = [50, 66, 107];
                const cheekboneRight = [280, 296, 334];
                
                const drawCheekboneHighlight = (points: number[]) => {
                    offscreenCtx.save();
                    offscreenCtx.filter = "blur(8px)";
                    offscreenCtx.beginPath();
                    offscreenCtx.strokeStyle = "rgba(255, 255, 255, 0.3)";
                    offscreenCtx.lineWidth = 2;
                    offscreenCtx.lineCap = "round";
                    points.forEach((index, i) => {
                        const pt = landmarks[index];
                        const x = pt.x * width;
                        const y = pt.y * height;
                        if (i === 0) offscreenCtx.moveTo(x, y);
                        else offscreenCtx.lineTo(x, y);
                    });
                    offscreenCtx.stroke();
                    offscreenCtx.restore();
                };
                
                drawCheekboneHighlight(cheekboneLeft);
                drawCheekboneHighlight(cheekboneRight);
            }
            
            // Th√™m hi·ªáu ·ª©ng b√≥ng m√¥i cho ki·ªÉu 'glamour' v√† 'soft'
            if (currentFilter === 'glamour' || currentFilter === 'soft') {
                offscreenCtx.save();
                offscreenCtx.filter = "blur(4px)";
                offscreenCtx.beginPath();
                offscreenCtx.fillStyle = currentFilter === 'glamour' 
                    ? "rgba(255, 255, 255, 0.35)" 
                    : "rgba(255, 255, 255, 0.3)";
                    
                const centerLip = landmarks[13];
                const lipX = centerLip.x * width;
                const lipY = centerLip.y * height - 3;
                
                // T·∫°o ƒëi·ªÉm nh·∫•n s√°ng nh·ªè ·ªü gi·ªØa m√¥i tr√™n
                offscreenCtx.arc(lipX, lipY, 4, 0, Math.PI * 2);
                offscreenCtx.fill();
                offscreenCtx.restore();
            }
        
            // L∆∞u l·∫°i k·∫øt qu·∫£ v√†o cache
            try {
                makeupImageRef.current = offscreenCtx.getImageData(0, 0, width, height);
            } catch (e) {
                console.error("[PersonalMakeup] Error getting ImageData:", e);
                // Kh√¥ng l∆∞u cache n·∫øu c√≥ l·ªói
                makeupImageRef.current = null;
            }
            
            // N·∫øu frame ·ªïn ƒë·ªãnh, l∆∞u v√†o cache ·ªïn ƒë·ªãnh ƒë·ªÉ s·ª≠ d·ª•ng khi kh√¥ng ·ªïn ƒë·ªãnh
            if (isFrameStable && makeupImageRef.current) {
                stableImageCacheRef.current = makeupImageRef.current;
            }
            
            // Copy t·ª´ offscreen canvas sang canvas ch√≠nh trong m·ªôt l·∫ßn th·ª±c hi·ªán
            ctx.clearRect(0, 0, width, height);
            ctx.drawImage(offscreenCanvasRef.current, 0, 0);
            
        } catch (error) {
            console.error("[PersonalMakeup] Error in drawMakeup:", error);
            // N·∫øu c√≥ l·ªói, s·ª≠ d·ª•ng cache n·∫øu c√≥
            if (makeupImageRef.current) {
                ctx.putImageData(makeupImageRef.current, 0, 0);
            }
        } finally {
            // K·∫øt th√∫c qu√° tr√¨nh v·∫Ω v√† cho ph√©p v·∫Ω ti·∫øp theo
            isRenderingRef.current = false;
        }
    }

    // Separate rendering loop - t√°ch ri√™ng lu·ªìng v·∫Ω ƒë·ªÉ tr√°nh nh·∫•p nh√°y
    useEffect(() => {
        if (!canvasRef.current || !displayVideoRef.current || !isVideoReady) return;

        const canvas = canvasRef.current;
        const ctx = canvas.getContext("2d", { willReadFrequently: true });
        if (!ctx) return;

        const renderLoop = () => {
            // Ch·ªâ v·∫Ω l·∫°i khi c√≥ landmarks v√† c·∫ßn render
            if (landmarksToRender.current) {
                drawMakeup(
                    ctx, 
                    landmarksToRender.current, 
                    canvas.width, 
                    canvas.height, 
                    renderRequestRef.current
                );
            } else if (stableImageCacheRef.current) {
                // N·∫øu kh√¥ng c√≥ landmarks nh∆∞ng c√≥ cache, v·∫Ω t·ª´ cache
                ctx.putImageData(stableImageCacheRef.current, 0, 0);
            }

            // Ti·∫øp t·ª•c v√≤ng l·∫∑p
            requestAnimationFrame(renderLoop);
        };

        // B·∫Øt ƒë·∫ßu v√≤ng l·∫∑p render
        requestAnimationFrame(renderLoop);

    }, [isVideoReady]);

    // Lu·ªìng ph√¢n t√≠ch v√† c·∫≠p nh·∫≠t landmarks ƒë·ªÉ v·∫Ω - t√°ch bi·ªát kh·ªèi lu·ªìng v·∫Ω
    useEffect(() => {
        if (!stream || !canvasRef.current || !displayVideoRef.current || !isVideoReady) {
            return;
        }
        
        const video = displayVideoRef.current;
        const canvas = canvasRef.current;
        
        // ƒê·∫£m b·∫£o k√≠ch th∆∞·ªõc canvas ph√π h·ª£p v·ªõi video
        const resizeCanvas = () => {
            if (video.videoWidth && video.videoHeight) {
                canvas.width = video.videoWidth;
                canvas.height = video.videoHeight;
                
                // C·∫≠p nh·∫≠t k√≠ch th∆∞·ªõc offscreen canvas
                if (offscreenCanvasRef.current) {
                    offscreenCanvasRef.current.width = video.videoWidth;
                    offscreenCanvasRef.current.height = video.videoHeight;
                }
            }
        };
        
        resizeCanvas();

        // T·ªëi ∆∞u h√≥a lu·ªìng ph√°t hi·ªán v√† c·∫≠p nh·∫≠t landmarks
        const detect = async () => {
            try {
                const now = performance.now();
                
                // NgƒÉn th·ª±c hi·ªán qu√° nhi·ªÅu frame trong m·ªôt th·ªùi gian ng·∫Øn
                const minInterval = filterTransitionRef.current 
                    ? 16 // 60fps khi ƒëang chuy·ªÉn filter cho m∆∞·ª£t
                    : handData.isHandDetected 
                        ? 100 // 10fps khi c√≥ tay ƒë·ªÉ ti·∫øt ki·ªám t√†i nguy√™n
                        : isFrameStable 
                            ? 33 // 30fps khi ·ªïn ƒë·ªãnh
                            : 66; // 15fps khi kh√¥ng ·ªïn ƒë·ªãnh
                
                if (now - lastDetectTime.current < minInterval && !filterTransitionRef.current && !renderRequestRef.current) {
                    animationFrameId.current = requestAnimationFrame(detect);
                    return;
                }
                
                lastDetectTime.current = now;
                
                // Ki·ªÉm tra y√™u c·∫ßu render m·ªõi
                if (renderRequestRef.current && now - lastRenderRequestTime.current > 300) {
                    // Reset y√™u c·∫ßu render n·∫øu ƒë√£ qu√° l√¢u
                    renderRequestRef.current = false;
                }
                
                // Ch·ªâ ph√¢n t√≠ch v√† v·∫Ω khi c√≥ landmarks khu√¥n m·∫∑t
                if (detectionResults?.face?.faceLandmarks && detectionResults?.face?.faceLandmarks.length > 0) {
                    const landmarks = detectionResults?.face?.faceLandmarks[0];
                    
                    // C·∫≠p nh·∫≠t landmarks ƒë·ªÉ render
                    landmarksToRender.current = landmarks;
                    
                    // Ki·ªÉm tra ·ªïn ƒë·ªãnh khu√¥n m·∫∑t (ch·ªâ khi kh√¥ng ph·∫£i ƒëang chuy·ªÉn filter)
                    if (!filterTransitionRef.current) {
                        checkFrameStability(landmarks);
                    }
                    
                    // Ch·ªâ ph√¢n t√≠ch khi c·∫ßn thi·∫øt (frame ·ªïn ƒë·ªãnh + th·ªùi gian ƒë·ªß l√¢u k·ªÉ t·ª´ l·∫ßn ph√¢n t√≠ch tr∆∞·ªõc)
                    const shouldAnalyze = (isFrameStable || filterTransitionRef.current) && 
                                         (!lastRenderedLandmarks.current || 
                                          now - lastAnalysisTime.current > 1000);
                                          
                    if (shouldAnalyze) {
                        // Ph√¢n t√≠ch khu√¥n m·∫∑t v√† t·∫°o g·ª£i √Ω
                        lastAnalysisTime.current = now;
                        lastRenderedLandmarks.current = landmarks;
                        
                        // S·ª≠ d·ª•ng cache ƒë·ªÉ tr√°nh ph√¢n t√≠ch l·∫∑p l·∫°i
                        if (!faceFeaturesCache.current) {
                            faceFeaturesCache.current = analyzeFacialFeatures(landmarks);
                        }
                        
                        // T·∫°o g·ª£i √Ω t·ª´ ƒë·∫∑c ƒëi·ªÉm khu√¥n m·∫∑t
                        const suggestion = generateMakeupSuggestion(faceFeaturesCache.current);
                        setMakeupSuggestion(suggestion);
                    }
                } else {
                    // Kh√¥ng ph√°t hi·ªán khu√¥n m·∫∑t - ch·ªâ reset landmarks khi khu√¥n m·∫∑t
                    // bi·∫øn m·∫•t ƒë·ªß l√¢u ƒë·ªÉ tr√°nh nh·∫•p nh√°y khi m·∫•t nh·∫≠n d·∫°ng m·ªôt l√∫c
                    if (noFaceDetectedDuration > 500) {
                        landmarksToRender.current = null;
                    }
                    
                    // Kh√¥ng reset lastRenderedLandmarks v√† faceFeaturesCache ngay l·∫≠p t·ª©c
                    // ƒë·ªÉ tr√°nh ph·∫£i ph√¢n t√≠ch l·∫°i khi m·∫∑t xu·∫•t hi·ªán tr·ªü l·∫°i trong th·ªùi gian ng·∫Øn
                    
                    // Ch·ªâ khi m·∫•t nh·∫≠n di·ªán m·∫∑t ƒë·ªß l√¢u m·ªõi reset c√°c gi√° tr·ªã
                    if (noFaceDetectedDuration > 3000) {
                        faceFeaturesCache.current = null;
                        lastRenderedLandmarks.current = null;
                        landmarksToRender.current = null;
                        setMakeupSuggestion(null);
                    }
                }
            } catch (err) {
                console.error("[PersonalMakeup] Error during analysis:", err);
            }

            animationFrameId.current = requestAnimationFrame(detect);
        };

        detect();

        return () => {
            if (animationFrameId.current) {
                cancelAnimationFrame(animationFrameId.current);
            }
        };
    }, [
        stream, 
        isVideoReady,
        handData.isHandDetected, 
        isFrameStable, 
        detectionResults, 
        checkFrameStability,
        prevStatusMessage,
        statusMessage,
        currentFilter,
        generateMakeupSuggestion,
        noFaceDetectedDuration
    ]);

    // X·ª≠ l√Ω ph√°t hi·ªán kh√¥ng c√≥ khu√¥n m·∫∑t - t·ªëi ∆∞u h√≥a interval
    useEffect(() => {
        // S·ª≠ d·ª•ng interval ƒë·ªÉ theo d√µi th·ªùi gian kh√¥ng ph√°t hi·ªán khu√¥n m·∫∑t
        const interval = setInterval(() => {
            if (!detectionResults || !detectionResults.face?.faceLandmarks) {
                setNoFaceDetectedDuration(prev => prev + 1000);
            } else {
                setNoFaceDetectedDuration(0);
            }
        }, 1000);

        return () => clearInterval(interval);
    }, [detectionResults]);

    // Th√™m x·ª≠ l√Ω chuy·ªÉn filter v·ªõi b√†n ph√≠m
    useEffect(() => {
        const handleKeyDown = (e: KeyboardEvent) => {
            // B·ªè qua n·∫øu ƒëang chuy·ªÉn filter
            if (filterTransitionRef.current) return;
            
            let newFilter: FilterType | null = null;
            
            switch(e.key) {
                case '1':
                    newFilter = 'natural';
                    break;
                case '2':
                    newFilter = 'glamour';
                    break;
                case '3': 
                    newFilter = 'soft';
                    break;
                case '4':
                    newFilter = 'dramatic';
                    break;
                case '5':
                    newFilter = 'nude';
                    break;
            }
            
            // Ch·ªâ x·ª≠ l√Ω ti·∫øp n·∫øu c√≥ filter m·ªõi v√† kh√°c filter hi·ªán t·∫°i
            if (newFilter && newFilter !== currentFilter) {
                // ƒê√°nh d·∫•u ƒëang trong qu√° tr√¨nh chuy·ªÉn filter
                filterTransitionRef.current = true;
                
                // X√≥a cache makeup ƒë·ªÉ bu·ªôc v·∫Ω l·∫°i
                makeupImageRef.current = null;
                
                // C·∫≠p nh·∫≠t filter m·ªõi
                setCurrentFilter(newFilter);
                
                // L∆∞u filter m·ªõi ngay l·∫≠p t·ª©c v√†o ref
                lastRenderedFilter.current = newFilter;
                
                // ƒê√°nh d·∫•u y√™u c·∫ßu render ngay
                renderRequestRef.current = true;
                lastRenderRequestTime.current = performance.now();
                
                // C·∫≠p nh·∫≠t l·∫°i g·ª£i √Ω makeup n·∫øu c√≥ ƒë·∫∑c ƒëi·ªÉm khu√¥n m·∫∑t
                if (faceFeaturesCache.current) {
                    const suggestion = generateMakeupSuggestion(faceFeaturesCache.current);
                    setMakeupSuggestion(suggestion);
                }
                
                // K·∫øt th√∫c qu√° tr√¨nh chuy·ªÉn filter sau 300ms
                setTimeout(() => {
                    filterTransitionRef.current = false;
                }, 300);
            }
        };
        
        window.addEventListener('keydown', handleKeyDown);
        
        return () => {
            window.removeEventListener('keydown', handleKeyDown);
        };
    }, [currentFilter, generateMakeupSuggestion]);

    // Th√™m double buffer ƒë·ªÉ gi·∫£m thi·ªÉu nh·∫•p nh√°y
    useEffect(() => {
        const setupDoubleBuffer = () => {
            if (!canvasRef.current || !displayVideoRef.current) return;
            
            const canvas = canvasRef.current;
            
            // T·∫°o ƒë·ªëi t∆∞·ª£ng CSS thu·ªôc t√≠nh cho canvas ƒë·ªÉ t·ªëi ∆∞u rendering
            if (canvas.style) {
                // Th√™m GPU acceleration
                canvas.style.willChange = 'transform';
                canvas.style.transform = 'translateZ(0)';
                canvas.style.backfaceVisibility = 'hidden';
                
                // ƒê·∫£m b·∫£o canvas kh√¥ng b·ªã m·ªù khi scale
                canvas.style.imageRendering = 'high-quality';
            }
        };
        
        setupDoubleBuffer();
    }, []);

    // Cleanup resources khi unmount
    useEffect(() => {
        return () => {
            // Gi·∫£i ph√≥ng c√°c t√†i nguy√™n
            if (makeupImageRef.current) {
                makeupImageRef.current = null;
            }
            
            if (stableImageCacheRef.current) {
                stableImageCacheRef.current = null;
            }
            
            if (offscreenCanvasRef.current) {
                offscreenCanvasRef.current = null;
            }
            
            if (animationFrameId.current) {
                cancelAnimationFrame(animationFrameId.current);
                animationFrameId.current = null;
            }
            
            // Reset c√°c refs kh√°c
            lastRenderedLandmarks.current = null;
            faceFeaturesCache.current = null;
            landmarksToRender.current = null;
        };
    }, []);

    return (
        <AnalysisLayout
            title="Personal Makeup"
            description="Get makeup suggestions based on your facial features."
            videoRef={displayVideoRef}
            canvasRef={canvasRef}
            result={makeupSuggestion}
            error={error || webcamError}
            statusMessage={statusMessage}
            progress={progress}
            detectionResults={detectionResults}
        />
    );
}
